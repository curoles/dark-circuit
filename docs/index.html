<!DOCTYPE html html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
    <title>Verilog documentation</title>

    <link rel="stylesheet" href="https://yarnpkg.com/en/package/normalize.css">

    <!-- see https://github.com/wavedrom/wavedrom -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/wavedrom/2.6.8/skins/default.js" type="text/javascript"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/wavedrom/2.6.8/wavedrom.min.js" type="text/javascript"></script>

    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/themes/prism.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/plugins/autoloader/prism-autoloader.min.js"></script>

    <style>
    pre { line-height: 125%; margin: 0; }
td.linenos pre { color: #000000; background-color: #f0f0f0; padding-left: 5px; padding-right: 5px; }
span.linenos { color: #000000; background-color: #f0f0f0; padding-left: 5px; padding-right: 5px; }
td.linenos pre.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.codehilite .hll { background-color: #ffffcc }
.codehilite .c { color: #408080; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #FF0000 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666666 } /* Operator */
.codehilite .ch { color: #408080; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #BC7A00 } /* Comment.Preproc */
.codehilite .cpf { color: #408080; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #408080; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #408080; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .gr { color: #FF0000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #00A000 } /* Generic.Inserted */
.codehilite .go { color: #888888 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #0044DD } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #7D9029 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.codehilite .no { color: #880000 } /* Name.Constant */
.codehilite .nd { color: #AA22FF } /* Name.Decorator */
.codehilite .ni { color: #999999; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #0000FF } /* Name.Function */
.codehilite .nl { color: #A0A000 } /* Name.Label */
.codehilite .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #bbbbbb } /* Text.Whitespace */
.codehilite .mb { color: #666666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666666 } /* Literal.Number.Float */
.codehilite .mh { color: #666666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #BB6688 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #0000FF } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666666 } /* Literal.Number.Integer.Long */
    </style>

    <style>
p {font-family: Verdana, Geneva, sans-serif;}

 /* The sidebar menu */
.sidenav {
  height: 100%; /* Full-height: remove this if you want "auto" height */
  width: 15rem; /* Set the width of the sidebar */
  position: fixed; /* Fixed Sidebar (stay in place on scroll) */
  z-index: 1; /* Stay on top */
  top: 0; /* Stay at the top */
  left: 0;
  background-color: #f0f0f0;
  overflow-x: hidden; /* Disable horizontal scroll */
  padding-top: 1rem;
}

/* The navigation menu links */
.sidenav a {
  padding: 6px 8px 6px 0.5rem;
  text-decoration: none;
  font-size: 1rem;
  color: black;
  display: block;
}

/* When you mouse over the navigation links, change their color */
.sidenav a:hover {
  color: blue;
  background-color: #e0e0e0;
}

/* Active/current link */
.sidenav a:active {
  color: #e0e0e0;
  background-color: blue;
}

/* Style page content */
.main {
  margin-left: 15rem; /* Same as the width of the sidebar */
  padding: 0px 10px;
}

/* On smaller screens, where height is less than 450px,
 * change the style of the sidebar (less padding and a smaller font size)
 */
@media screen and (max-height: 450px) {
  .sidenav {padding-top: 0.5rem;}
  .sidenav a {font-size: 0.5rem;}
}
</style>
</head>

<body onload="WaveDrom.ProcessAll()">
<div class="sidenav">
    <h3>- blocks/ALU1/rtl</h3>
    <a href="#module_blocks/ALU1/rtl/Alu1.sv">Alu1</a>
    <h3>- blocks/AddCmp/rtl</h3>
    <a href="#module_blocks/AddCmp/rtl/AddCmp50.sv">AddCmp50</a>
    <h3>- blocks/BarrelShifter/rtl</h3>
    <a href="#module_blocks/BarrelShifter/rtl/BarrelShifter.sv">BarrelShifter</a>
    <h3>- blocks/Counter/rtl</h3>
    <a href="#module_blocks/Counter/rtl/Counter.sv">Counter</a>
    <h3>- blocks/Decoder/rtl</h3>
    <a href="#module_blocks/Decoder/rtl/Decoder.sv">Decoder</a>
    <h3>- blocks/Encoder/rtl</h3>
    <a href="#module_blocks/Encoder/rtl/Encoder8_3.sv">Encoder8_3</a>
    <h3>- blocks/Incr/rtl</h3>
    <a href="#module_blocks/Incr/rtl/Incr16.sv">Incr16</a>
    <a href="#module_blocks/Incr/rtl/Incr3.sv">Incr3</a>
    <a href="#module_blocks/Incr/rtl/Incr4.sv">Incr4</a>
    <a href="#module_blocks/Incr/rtl/Incr9.sv">Incr9</a>
    <h3>- blocks/JtagCoreDbg/rtl</h3>
    <a href="#module_blocks/JtagCoreDbg/rtl/JtagTap.sv">JtagTap</a>
    <a href="#module_blocks/JtagCoreDbg/rtl/JtagTapFsm.sv">JtagTapFsm</a>
    <h3>- blocks/PrgCounter/rtl</h3>
    <a href="#module_blocks/PrgCounter/rtl/PrgCounter.sv">PrgCounter</a>
    <h3>- blocks/ShiftReg/rtl</h3>
    <a href="#module_blocks/ShiftReg/rtl/ShiftReg.sv">ShiftReg</a>
    <h3>- blocks/SimRAM/rtl</h3>
    <a href="#module_blocks/SimRAM/rtl/SimRAM.sv">SimRAM</a>
    <h3>- blocks/SimROM/rtl</h3>
    <a href="#module_blocks/SimROM/rtl/SimROM.sv">SimROM</a>
    <h3>- lib/gates/builtin</h3>
    <a href="#module_lib/gates/builtin/INV.sv">INV</a>
    <a href="#module_lib/gates/builtin/Inv.sv">Inv</a>
    <a href="#module_lib/gates/builtin/MUX2.sv">MUX2</a>
    <a href="#module_lib/gates/builtin/Mux2.sv">Mux2</a>
    <a href="#module_lib/gates/builtin/NAND2.sv">NAND2</a>
    <a href="#module_lib/gates/builtin/NAnd2.sv">NAnd2</a>
    <h3>- lib/gates/cmos</h3>
    <a href="#module_lib/gates/cmos/AND2.sv">AND2</a>
    <a href="#module_lib/gates/cmos/INV.sv">INV</a>
    <a href="#module_lib/gates/cmos/Inv.sv">Inv</a>
    <a href="#module_lib/gates/cmos/MUX2.sv">MUX2</a>
    <a href="#module_lib/gates/cmos/Mux2.sv">Mux2</a>
    <a href="#module_lib/gates/cmos/NAND2.sv">NAND2</a>
    <a href="#module_lib/gates/cmos/NAnd2.sv">NAnd2</a>
    <a href="#module_lib/gates/cmos/NOR2.sv">NOR2</a>
    <a href="#module_lib/gates/cmos/NOr2.sv">NOr2</a>
    <h3>- lib/gates/generic</h3>
    <a href="#module_lib/gates/generic/AOI22.sv">AOI22</a>
    <a href="#module_lib/gates/generic/Dff.sv">Dff</a>
    <a href="#module_lib/gates/generic/INV.sv">INV</a>
    <a href="#module_lib/gates/generic/MUX2.sv">MUX2</a>
    <a href="#module_lib/gates/generic/MUX4.sv">MUX4</a>
    <a href="#module_lib/gates/generic/Mux2.sv">Mux2</a>
    <a href="#module_lib/gates/generic/Mux4.sv">Mux4</a>
    <a href="#module_lib/gates/generic/NAND2.sv">NAND2</a>
    <h3>- lib/parts</h3>
    <a href="#module_lib/parts/FullAdderAOI.sv">FullAdderAOI</a>
    <a href="#module_lib/parts/RippleCarryAdder.sv">RippleCarryAdder</a>
</div>
<div class="main">
<h3 id="module_blocks/ALU1/rtl/Alu1.sv">
Module "Alu1", blocks/ALU1/rtl/Alu1.sv
</h3>

<h4>Parameters:</h4>
<ul>
    <li>
    WIDTH
    </li>

    <li>
    localparam
    </li>

</ul>

<h4>Ports:</h4>
<ul>
    <li>
    <pre>cmd      input    wire [CMD_WIDTH-1:0]</pre>
    </li>

    <li>
    <pre>in1      input    wire [WIDTH-1:0]</pre>
    </li>

    <li>
    <pre>in2      input    wire [WIDTH-1:0]</pre>
    </li>

    <li>
    <pre>co       output   wire</pre>
    </li>

    <li>
    <pre>out      output   wire [WIDTH-1:0]</pre>
    </li>

</ul>

<p>Substraction is using 2's complements.
 Negating B is to find its 2's complement, 2's complement of B is ~B + 1,
 that is invert and add 1.
 Therefore A - B = A + B2s = A + ~B + 1.
 When using RippleCarryAdder we need:
 1. set carry in <code>ci</code> to HI for +1, ci = sub_add;
 2. B' = ~B = B XOR sub_add.</p>
<script type="WaveDrom">
 { assign:[
   ["adder_input2",
     ["|", ["&", "in", "S0"],
           ["&", ["~","in"], "S1"]
     ]
   ]
 ]}
 </script>

<p>References:
 - https://www.egr.msu.edu/classes/ece410/mason/files/Ch12.pdf</p>
<p>Source code:</p>
<pre><code class="lang-verilog">module Alu1 #(
    parameter WIDTH = 64,
    localparam CMD_WIDTH = ALU1_CMD_WIDTH
)(
    input  wire [CMD_WIDTH-1:0] cmd,
    input  wire [WIDTH-1:0]     in1,
    input  wire [WIDTH-1:0]     in2,
    output wire                 co,
    output wire [WIDTH-1:0]     out
);

                                   //S012 C cmd
    localparam CMD_TRANSFER   = 0; // 000 0 0000 out = in1
    localparam CMD_INC        = 1; // 000 1 0001 out = in1 + 1
    localparam CMD_ADD        = 2; // 100 0 0010 out = in1 + in2
    localparam CMD_ADD_PLUS1  = 3; // 100 1 0011 out = in1 + in2 + 1
    localparam CMD_SUB_MINUS1 = 4; // 010 0 0100 out = in1 + ~in2
    localparam CMD_SUB        = 5; // 010 1 0101 out = in1 + ~in2 + 1
    localparam CMD_DEC        = 6; // 110 0 0110 out = in1 - 1 (in1 + 111=in1 + 000 - 1=in1 - 1)
    localparam CMD_TRANSFER2  = 7; // 110 1 0111 out = in1

    localparam CMD_AND        = 8; // 001   1000 out = in1 & in2
    localparam CMD_OR         = 9; // 101   1001 out = in1 | in2
    localparam CMD_XOR        =10; // 011   1010 out = in1 ^ in2
    localparam CMD_NOT        =11; // 111   1011 out = ~in1

    wire [2:0] opsel;

    assign opsel[0] = (cmd == CMD_ADD || cmd == CMD_ADD_PLUS1 ||
        cmd == CMD_DEC || cmd == CMD_TRANSFER2 || cmd == CMD_OR || cmd == CMD_NOT);

    assign opsel[1] = cmd[2] | (cmd[3] & cmd[1]);

    assign opsel[2] = cmd[3];

    wire [WIDTH-1:0] in2_inv;

    INV#(WIDTH) inv2_(.in(in2), .out(in2_inv));

    wire [WIDTH-1:0] adder_in1;
    wire [WIDTH-1:0] adder_in2;
    wire [WIDTH-1:0] adder_out;
    wire             adder_ci;

    assign adder_in1 = in1;

    assign adder_ci = cmd[0];

    genvar i;
    generate
    for (i = 0; i < WIDTH; i++) begin : in2_sel
        assign adder_in2[i] = (in2[i] & opsel[0]) | (in2_inv[i] & opsel[1]);
    end
    endgenerate

    RippleCarryAdder#(WIDTH) adder_(
        .in1(adder_in1),
        .in2(adder_in2),
        .ci(adder_ci),
        .co(co),
        .sum(adder_out)
    );

    wire [WIDTH-1:0] logic_block_out;

    MUX4#(WIDTH) logic_block_(
        .in1(in1 & in2), // AND
        .in2(in1 | in2), // OR
        .in3(in1 ^ in2), // XOR
        .in4(~in1),      // NOT
        .sel(opsel[1:0]),
        .out(logic_block_out)
    );

    assign out = (opsel[2] == 1)? logic_block_out : adder_out;


endmodule</code></pre>


<hr />
<h3 id="module_blocks/AddCmp/rtl/AddCmp50.sv">
Module "AddCmp50", blocks/AddCmp/rtl/AddCmp50.sv
</h3>

<h4>Parameters:</h4>
<ul>
</ul>

<h4>Ports:</h4>
<ul>
    <li>
    <pre>a        input    wire [50-1:0]</pre>
    </li>

    <li>
    <pre>b        input    wire [50-1:0]</pre>
    </li>

    <li>
    <pre>c        input    wire [50-1:0]</pre>
    </li>

    <li>
    <pre>eq       output   wire</pre>
    </li>

</ul>


<p>Source code:</p>
<pre><code class="lang-verilog">module AddCmp50 (
    input  wire [50-1:0] a,
    input  wire [50-1:0] b,
    input  wire [50-1:0] c,
    output wire          eq
);

wire [50-1:0] s;
wire [50  :0] cy;
wire [50-1:0] t;
wire group0;
wire group1;
wire group2;
wire group3;
wire group4;
wire group5;
wire group6;
wire group7;
wire group8;
wire group9;
wire group10;
wire group11;
wire group12;

assign cy[0] = 0;

FullAdder u_fa0(.in1(a[0]), .in2(b[0]), .ci(~c[0]), .sum(s[0]), .co(cy[1]));
FullAdder u_fa1(.in1(a[1]), .in2(b[1]), .ci(~c[1]), .sum(s[1]), .co(cy[2]));
FullAdder u_fa2(.in1(a[2]), .in2(b[2]), .ci(~c[2]), .sum(s[2]), .co(cy[3]));
FullAdder u_fa3(.in1(a[3]), .in2(b[3]), .ci(~c[3]), .sum(s[3]), .co(cy[4]));
FullAdder u_fa4(.in1(a[4]), .in2(b[4]), .ci(~c[4]), .sum(s[4]), .co(cy[5]));
FullAdder u_fa5(.in1(a[5]), .in2(b[5]), .ci(~c[5]), .sum(s[5]), .co(cy[6]));
FullAdder u_fa6(.in1(a[6]), .in2(b[6]), .ci(~c[6]), .sum(s[6]), .co(cy[7]));
FullAdder u_fa7(.in1(a[7]), .in2(b[7]), .ci(~c[7]), .sum(s[7]), .co(cy[8]));
FullAdder u_fa8(.in1(a[8]), .in2(b[8]), .ci(~c[8]), .sum(s[8]), .co(cy[9]));
FullAdder u_fa9(.in1(a[9]), .in2(b[9]), .ci(~c[9]), .sum(s[9]), .co(cy[10]));
FullAdder u_fa10(.in1(a[10]), .in2(b[10]), .ci(~c[10]), .sum(s[10]), .co(cy[11]));
FullAdder u_fa11(.in1(a[11]), .in2(b[11]), .ci(~c[11]), .sum(s[11]), .co(cy[12]));
FullAdder u_fa12(.in1(a[12]), .in2(b[12]), .ci(~c[12]), .sum(s[12]), .co(cy[13]));
FullAdder u_fa13(.in1(a[13]), .in2(b[13]), .ci(~c[13]), .sum(s[13]), .co(cy[14]));
FullAdder u_fa14(.in1(a[14]), .in2(b[14]), .ci(~c[14]), .sum(s[14]), .co(cy[15]));
FullAdder u_fa15(.in1(a[15]), .in2(b[15]), .ci(~c[15]), .sum(s[15]), .co(cy[16]));
FullAdder u_fa16(.in1(a[16]), .in2(b[16]), .ci(~c[16]), .sum(s[16]), .co(cy[17]));
FullAdder u_fa17(.in1(a[17]), .in2(b[17]), .ci(~c[17]), .sum(s[17]), .co(cy[18]));
FullAdder u_fa18(.in1(a[18]), .in2(b[18]), .ci(~c[18]), .sum(s[18]), .co(cy[19]));
FullAdder u_fa19(.in1(a[19]), .in2(b[19]), .ci(~c[19]), .sum(s[19]), .co(cy[20]));
FullAdder u_fa20(.in1(a[20]), .in2(b[20]), .ci(~c[20]), .sum(s[20]), .co(cy[21]));
FullAdder u_fa21(.in1(a[21]), .in2(b[21]), .ci(~c[21]), .sum(s[21]), .co(cy[22]));
FullAdder u_fa22(.in1(a[22]), .in2(b[22]), .ci(~c[22]), .sum(s[22]), .co(cy[23]));
FullAdder u_fa23(.in1(a[23]), .in2(b[23]), .ci(~c[23]), .sum(s[23]), .co(cy[24]));
FullAdder u_fa24(.in1(a[24]), .in2(b[24]), .ci(~c[24]), .sum(s[24]), .co(cy[25]));
FullAdder u_fa25(.in1(a[25]), .in2(b[25]), .ci(~c[25]), .sum(s[25]), .co(cy[26]));
FullAdder u_fa26(.in1(a[26]), .in2(b[26]), .ci(~c[26]), .sum(s[26]), .co(cy[27]));
FullAdder u_fa27(.in1(a[27]), .in2(b[27]), .ci(~c[27]), .sum(s[27]), .co(cy[28]));
FullAdder u_fa28(.in1(a[28]), .in2(b[28]), .ci(~c[28]), .sum(s[28]), .co(cy[29]));
FullAdder u_fa29(.in1(a[29]), .in2(b[29]), .ci(~c[29]), .sum(s[29]), .co(cy[30]));
FullAdder u_fa30(.in1(a[30]), .in2(b[30]), .ci(~c[30]), .sum(s[30]), .co(cy[31]));
FullAdder u_fa31(.in1(a[31]), .in2(b[31]), .ci(~c[31]), .sum(s[31]), .co(cy[32]));
FullAdder u_fa32(.in1(a[32]), .in2(b[32]), .ci(~c[32]), .sum(s[32]), .co(cy[33]));
FullAdder u_fa33(.in1(a[33]), .in2(b[33]), .ci(~c[33]), .sum(s[33]), .co(cy[34]));
FullAdder u_fa34(.in1(a[34]), .in2(b[34]), .ci(~c[34]), .sum(s[34]), .co(cy[35]));
FullAdder u_fa35(.in1(a[35]), .in2(b[35]), .ci(~c[35]), .sum(s[35]), .co(cy[36]));
FullAdder u_fa36(.in1(a[36]), .in2(b[36]), .ci(~c[36]), .sum(s[36]), .co(cy[37]));
FullAdder u_fa37(.in1(a[37]), .in2(b[37]), .ci(~c[37]), .sum(s[37]), .co(cy[38]));
FullAdder u_fa38(.in1(a[38]), .in2(b[38]), .ci(~c[38]), .sum(s[38]), .co(cy[39]));
FullAdder u_fa39(.in1(a[39]), .in2(b[39]), .ci(~c[39]), .sum(s[39]), .co(cy[40]));
FullAdder u_fa40(.in1(a[40]), .in2(b[40]), .ci(~c[40]), .sum(s[40]), .co(cy[41]));
FullAdder u_fa41(.in1(a[41]), .in2(b[41]), .ci(~c[41]), .sum(s[41]), .co(cy[42]));
FullAdder u_fa42(.in1(a[42]), .in2(b[42]), .ci(~c[42]), .sum(s[42]), .co(cy[43]));
FullAdder u_fa43(.in1(a[43]), .in2(b[43]), .ci(~c[43]), .sum(s[43]), .co(cy[44]));
FullAdder u_fa44(.in1(a[44]), .in2(b[44]), .ci(~c[44]), .sum(s[44]), .co(cy[45]));
FullAdder u_fa45(.in1(a[45]), .in2(b[45]), .ci(~c[45]), .sum(s[45]), .co(cy[46]));
FullAdder u_fa46(.in1(a[46]), .in2(b[46]), .ci(~c[46]), .sum(s[46]), .co(cy[47]));
FullAdder u_fa47(.in1(a[47]), .in2(b[47]), .ci(~c[47]), .sum(s[47]), .co(cy[48]));
FullAdder u_fa48(.in1(a[48]), .in2(b[48]), .ci(~c[48]), .sum(s[48]), .co(cy[49]));
FullAdder u_fa49(.in1(a[49]), .in2(b[49]), .ci(~c[49]), .sum(s[49]), .co(cy[50]));

assign t[0] = cy[0] ^ s[0];
assign t[1] = cy[1] ^ s[1];
assign t[2] = cy[2] ^ s[2];
assign t[3] = cy[3] ^ s[3];
assign t[4] = cy[4] ^ s[4];
assign t[5] = cy[5] ^ s[5];
assign t[6] = cy[6] ^ s[6];
assign t[7] = cy[7] ^ s[7];
assign t[8] = cy[8] ^ s[8];
assign t[9] = cy[9] ^ s[9];
assign t[10] = cy[10] ^ s[10];
assign t[11] = cy[11] ^ s[11];
assign t[12] = cy[12] ^ s[12];
assign t[13] = cy[13] ^ s[13];
assign t[14] = cy[14] ^ s[14];
assign t[15] = cy[15] ^ s[15];
assign t[16] = cy[16] ^ s[16];
assign t[17] = cy[17] ^ s[17];
assign t[18] = cy[18] ^ s[18];
assign t[19] = cy[19] ^ s[19];
assign t[20] = cy[20] ^ s[20];
assign t[21] = cy[21] ^ s[21];
assign t[22] = cy[22] ^ s[22];
assign t[23] = cy[23] ^ s[23];
assign t[24] = cy[24] ^ s[24];
assign t[25] = cy[25] ^ s[25];
assign t[26] = cy[26] ^ s[26];
assign t[27] = cy[27] ^ s[27];
assign t[28] = cy[28] ^ s[28];
assign t[29] = cy[29] ^ s[29];
assign t[30] = cy[30] ^ s[30];
assign t[31] = cy[31] ^ s[31];
assign t[32] = cy[32] ^ s[32];
assign t[33] = cy[33] ^ s[33];
assign t[34] = cy[34] ^ s[34];
assign t[35] = cy[35] ^ s[35];
assign t[36] = cy[36] ^ s[36];
assign t[37] = cy[37] ^ s[37];
assign t[38] = cy[38] ^ s[38];
assign t[39] = cy[39] ^ s[39];
assign t[40] = cy[40] ^ s[40];
assign t[41] = cy[41] ^ s[41];
assign t[42] = cy[42] ^ s[42];
assign t[43] = cy[43] ^ s[43];
assign t[44] = cy[44] ^ s[44];
assign t[45] = cy[45] ^ s[45];
assign t[46] = cy[46] ^ s[46];
assign t[47] = cy[47] ^ s[47];
assign t[48] = cy[48] ^ s[48];
assign t[49] = cy[49] ^ s[49];

assign group0 = ~(t[0] & t[1] & t[2] & t[3]);
assign group1 = ~(t[4] & t[5] & t[6] & t[7]);
assign group2 = ~(t[8] & t[9] & t[10] & t[11]);
assign group3 = ~(t[12] & t[13] & t[14] & t[15]);
assign group4 = ~(t[16] & t[17] & t[18] & t[19]);
assign group5 = ~(t[20] & t[21] & t[22] & t[23]);
assign group6 = ~(t[24] & t[25] & t[26] & t[27]);
assign group7 = ~(t[28] & t[29] & t[30] & t[31]);
assign group8 = ~(t[32] & t[33] & t[34] & t[35]);
assign group9 = ~(t[36] & t[37] & t[38] & t[39]);
assign group10 = ~(t[40] & t[41] & t[42] & t[43]);
assign group11 = ~(t[44] & t[45] & t[46] & t[47]);
assign group12 = ~(t[48] & t[49]);

assign eq = ~(group0 | group1 | group2 | group3 | group4 | group5 | group6 | group7 | group8 | group9 | group10 | group11 | group12);

endmodule</code></pre>


<hr />
<h3 id="module_blocks/BarrelShifter/rtl/BarrelShifter.sv">
Module "BarrelShifter", blocks/BarrelShifter/rtl/BarrelShifter.sv
</h3>

<h4>Parameters:</h4>
<ul>
    <li>
    WIDTH
    </li>

    <li>
    SHIFT_WIDTH
    </li>

</ul>

<h4>Ports:</h4>
<ul>
    <li>
    <pre>in       input    wire [WIDTH-1:0]</pre>
    </li>

    <li>
    <pre>shift_in_bit input    wire</pre>
     0 for logical shift
    </li>

    <li>
    <pre>shift    input    wire [SHIFT_WIDTH-1:0]</pre>
     number of shifts
    </li>

    <li>
    <pre>shift_rotate input    wire</pre>
     shift or rotate
    </li>

    <li>
    <pre>left_right input    wire</pre>
     shift/rotate left or right
    </li>

    <li>
    <pre>out      output   wire [WIDTH-1:0]</pre>
    </li>

</ul>

<p>Barrel Shifter
Author: Igor Lesik 2019-2020
Copyright: Igor Lesik 2019-2020</p>
<p>Source code:</p>
<pre><code class="lang-verilog">module BarrelShifter #(
    parameter WIDTH = 64,
    parameter SHIFT_WIDTH = `CLOG2(WIDTH) // number of shift/rotate bits
)(
    input  wire [WIDTH-1:0]       in,
    input  wire                   shift_in_bit, // 0 for logical shift
    input  wire [SHIFT_WIDTH-1:0] shift,        // number of shifts
    input  wire                   shift_rotate, // shift or rotate
    input  wire                   left_right,   // shift/rotate left or right
    output wire [WIDTH-1:0]       out
);

    wire [WIDTH-1:0] ain; // "in" or reversed "in"

    wire [WIDTH-1:0] res; // result of shifting

    genvar i;

    // We implement internal logic that shift/rotate LEFT.
    // The direction of the final shift/rotate operation is implemented by reversing
    // the input and output vector.
    generate //: reverse_vectors
        for (i = 0; i < WIDTH; i = i + 1)
        begin: gen_reverse
            MUX2#(.WIDTH(1)) mux_reverse_in_ (.in1(in[i]), .in2(in[WIDTH-1-i]), .sel(left_right), .out(ain[i]));
            MUX2#(.WIDTH(1)) mux_reverse_out_ (.in1(res[i]), .in2(res[WIDTH-1-i]), .sel(left_right), .out(out[i]));
        end: gen_reverse
    endgenerate

    // The shift/rotate (left) operation is done in stages where each stage performs
    // a shift/rotate operation of a different size.
    // For example, a 5 bits shift operation would result in a shift of 4 and a shift of 1
    // where the stage that performs the shift of 2 would not do any shift.
    // The select vector binary encoding is actually to enable the different stages of the barrel shifter.

    // {stage[i+1][WIDTH-(2**i)-1:0], stage[i+1][WIDTH-1:WIDTH-(2**i)]}) when WIDTH=8:
    // s3 = in                   76543210
    // s2 = {s3[3:0],s3[7:4]} -> 32107654
    // s1 = {s2[5:0],s3[7:6]} -> 10765432
    // s0 = {s1[6:0],s1[7:7]} -> 07654321

    wire [WIDTH-1:0] stage[SHIFT_WIDTH:0];
    assign stage[SHIFT_WIDTH] = ain;
    assign res = stage[0];

    generate //: stage_select
        for (i = 0; i < SHIFT_WIDTH; i = i + 1)
        begin: stage_mux
            Mux2 #(.WIDTH(WIDTH)) mux(
               .in2(stage[i+1]),
               .in1({stage[i+1][WIDTH-(2**i)-1:0],
                        (shift_rotate)? {(2**i){shift_in_bit}} : stage[i+1][WIDTH-1:WIDTH-(2**i)]
                    }),
               .sel(shift[i]), // i-th bit of shift
               .out(stage[i])  // i-th stage either copy of prev. stage
            );
        end: stage_mux
    endgenerate //: stage_select


endmodule</code></pre>


<hr />
<h3 id="module_blocks/Counter/rtl/Counter.sv">
Module "Counter", blocks/Counter/rtl/Counter.sv
</h3>

<h4>Parameters:</h4>
<ul>
    <li>
    WIDTH
    </li>

</ul>

<h4>Ports:</h4>
<ul>
    <li>
    <pre>clk      input    wire</pre>
    </li>

    <li>
    <pre>rst_n    input    wire</pre>
    </li>

    <li>
    <pre>load     input    wire</pre>
    </li>

    <li>
    <pre>in       input    wire [WIDTH-1:0]</pre>
    </li>

    <li>
    <pre>up_down  input    wire</pre>
    </li>

    <li>
    <pre>count_en input    wire</pre>
    </li>

    <li>
    <pre>out      output   reg [WIDTH-1:0]</pre>
    </li>

    <li>
    <pre>co       output   reg</pre>
    </li>

</ul>


<p>Source code:</p>
<pre><code class="lang-verilog">module Counter #(
    parameter WIDTH=8
)(
    input  wire             clk,
    input  wire             rst_n,
    input  wire             load,
    input  wire [WIDTH-1:0] in,
    input  wire             up_down,
    input  wire             count_en,
    output reg  [WIDTH-1:0] out,
    output reg              co
);

    localparam WIDTH_WITH_CARRY = WIDTH + 1;

    always @(posedge clk)
    begin
        if (!rst_n) begin         // sync reset
            {co,out} <= {WIDTH_WITH_CARRY{1'b0}};
        end else if (load) begin  // sync load
            {co,out} <= in;
        end else if (count_en) begin // sync increment/decrement
            if (up_down)
                {co,out} <= out + 1'b1;
            else
                {co,out} <= out - 1'b1;
        end
    end

endmodule</code></pre>


<hr />
<h3 id="module_blocks/Decoder/rtl/Decoder.sv">
Module "Decoder", blocks/Decoder/rtl/Decoder.sv
</h3>

<h4>Parameters:</h4>
<ul>
    <li>
    SIZE
    </li>

    <li>
    WIDTH
    </li>

</ul>

<h4>Ports:</h4>
<ul>
    <li>
    <pre>in       input    wire [SIZE-1:0]</pre>
    </li>

    <li>
    <pre>en       input    wire</pre>
    </li>

    <li>
    <pre>out      output   wire [WIDTH-1:0]</pre>
    </li>

</ul>

<p>i[j] - take j-th bit of number i
 For example, for 3-8 decoder:
     If in is 5(101), 5[0]=1, 5[1]=0, 5[2]=1
     for i [0..7]
         i=5=b101, 5[0]=1, 5[1]=0, 5[2]=1
         out[5]=5[0] &amp; !5[1] &amp; !5[2] = 1 &amp; !0 &amp; 1 = 1</p>
<div class="codehilite"><pre><span></span><code><span class="err">     i=6=b110, 6[0]=0, 6[1]=1, 6[2]=1</span>
<span class="err">     out[6]=!5[0] &amp; 5[1] &amp; 5[2] = !1 &amp; 0 &amp; 1 = 0 &amp; 0 &amp; 1 = 0</span>
</code></pre></div>
<p>Source code:</p>
<pre><code class="lang-verilog">module Decoder #(
    parameter SIZE = 3,
    parameter WIDTH = 1 << SIZE
)(
    input  wire [SIZE-1:0]  in,
    input  wire             en,
    output wire [WIDTH-1:0] out
);

/*
always @* begin
  out = {WIDTH{1'b0}};
  out[in] = 1'b1;
end
*/

wire [SIZE-1:0] nin;
assign nin = ~in;

genvar i, j;
generate
for (i = 0; i < WIDTH; i = i + 1) begin
    wire [SIZE-1:0] sel;
    for (j = 0; j < SIZE; j = j + 1) begin
        assign sel[j] = i[j] ? in[j] : nin[j];
    end
    assign out[i] = en & ( &sel );
end
endgenerate

endmodule</code></pre>


<hr />
<h3 id="module_blocks/Encoder/rtl/Encoder8_3.sv">
Module "Encoder8_3", blocks/Encoder/rtl/Encoder8_3.sv
</h3>

<h4>Parameters:</h4>
<ul>
</ul>

<h4>Ports:</h4>
<ul>
    <li>
    <pre>in       input    wire [8-1:0]</pre>
    </li>

    <li>
    <pre>out      output   wire [3-1:0]</pre>
    </li>

    <li>
    <pre>d        input     [WIDTH-1:0]</pre>
    </li>

</ul>


<p>Source code:</p>
<pre><code class="lang-verilog">module Encoder8_3(
    input  wire [8-1:0]  in,
    output wire [3-1:0]  out
);

localparam SIZE = 3;
localparam WIDTH = 1 << SIZE;

assign out = enc(in);

function [SIZE-1:0] enc(input [WIDTH-1:0] d);
    casex (d)
        8'b1xxxxxxx: enc = 3'd7;
        8'b01xxxxxx: enc = 3'd6;
        8'b001xxxxx: enc = 3'd5;
        8'b0001xxxx: enc = 3'd4;
        8'b00001xxx: enc = 3'd3;
        8'b000001xx: enc = 3'd2;
        8'b0000001x: enc = 3'd1;
        default:     enc = 3'd0;
    endcase
endfunction

endmodule</code></pre>


<hr />
<h3 id="module_blocks/Incr/rtl/Incr16.sv">
Module "Incr16", blocks/Incr/rtl/Incr16.sv
</h3>

<h4>Parameters:</h4>
<ul>
</ul>

<h4>Ports:</h4>
<ul>
    <li>
    <pre>in       input    wire [15:0]</pre>
    </li>

    <li>
    <pre>out      output   wire [15:0]</pre>
    </li>

    <li>
    <pre>cy       output   wire</pre>
    </li>

</ul>

<p>16-bit Incrementor.</p>
<p>Source code:</p>
<pre><code class="lang-verilog">module Incr16 (
    input  wire [15:0] in,
    output wire [15:0] out,
    output wire        cy
);

wire [ 3: 0] all1_3_0;
wire [ 7: 4] all1_7_4;
wire [11: 8] all1_11_8;
wire [15:12] all1_15_12;

wire [ 3: 0] incr_3_0;
wire [ 7: 4] incr_7_4;
wire [11: 8] incr_11_8;
wire [15:12] incr_15_12;

assign all1_3_0   = ~(in[ 3] & in[ 2] & in[ 1] & in[ 0]);
assign all1_7_4   = ~(in[ 7] & in[ 6] & in[ 5] & in[ 4]);
assign all1_11_8  = ~(in[11] & in[10] & in[ 9] & in[ 8]);
assign all1_15_12 = ~(in[15] & in[14] & in[13] & in[12]);

Incr4 u_incr_3_0  (.in(in[ 3: 0]), .out(incr_3_0));
Incr4 u_incr_7_4  (.in(in[ 7: 4]), .out(incr_7_4));
Incr4 u_incr_11_8 (.in(in[11: 8]), .out(incr_11_8));
Incr4 u_incr_15_12(.in(in[15:12]), .out(incr_15_12));

assign out[ 3: 0] = incr_3_0;
assign out[ 7: 4] = ~all1_3_0                          ? incr_7_4   : in[7:4];
assign out[11: 8] = ~(all1_3_0 | all1_7_4)             ? incr_11_8  : in[11:8];
assign out[15:12] = ~(all1_3_0 | all1_7_4 | all1_11_8) ? incr_15_12 : in[15:12];
assign         cy = ~(all1_3_0 | all1_7_4 | all1_11_8 | all1_15_12);

endmodule</code></pre>


<hr />
<h3 id="module_blocks/Incr/rtl/Incr3.sv">
Module "Incr3", blocks/Incr/rtl/Incr3.sv
</h3>

<h4>Parameters:</h4>
<ul>
</ul>

<h4>Ports:</h4>
<ul>
    <li>
    <pre>in       input    wire [2:0]</pre>
    </li>

    <li>
    <pre>out      output   wire [2:0]</pre>
    </li>

</ul>

<p>3-bit Incrementor block to be used in building Nx3 Fast Incrementor.</p>
<p>Source code:</p>
<pre><code class="lang-verilog">module Incr3 (
    input  wire [2:0] in,
    output wire [2:0] out
);

assign out[0] = ~in[0];
assign out[1] = ~(~( in[0] & ~in[1]) &
                  ~(~in[0] &  in[1]));
assign out[2] = ~(~( in[0] &  in[1] & ~in[2]) &
                  ~(         ~in[1] &  in[2]) &
                  ~(~in[0] &  in[1] &  in[2]));

endmodule</code></pre>


<hr />
<h3 id="module_blocks/Incr/rtl/Incr4.sv">
Module "Incr4", blocks/Incr/rtl/Incr4.sv
</h3>

<h4>Parameters:</h4>
<ul>
</ul>

<h4>Ports:</h4>
<ul>
    <li>
    <pre>in       input    wire [3:0]</pre>
    </li>

    <li>
    <pre>out      output   wire [3:0]</pre>
    </li>

</ul>

<p>4-bit Incrementor.</p>
<p>Source code:</p>
<pre><code class="lang-verilog">module Incr4 (
    input  wire [3:0] in,
    output wire [3:0] out
);

assign out[0] = ~in[0];
assign out[1] = ~(~( in[0] & ~in[1]) &
                  ~(~in[0] &  in[1]));
assign out[2] = ~(~( in[0] &  in[1] & ~in[2]) &
                  ~(         ~in[1] &  in[2]) &
                  ~(~in[0] &  in[1] &  in[2]));
assign out[3] = ~(~( in[0] &  in[1] &  in[2] & ~in[3]) &
                  ~(                  ~in[2] &  in[3]) &
                  ~(         ~in[1] &  in[2] &  in[3]) &
                  ~(~in[0] &  in[1] &  in[2] &  in[3]));

endmodule</code></pre>


<hr />
<h3 id="module_blocks/Incr/rtl/Incr9.sv">
Module "Incr9", blocks/Incr/rtl/Incr9.sv
</h3>

<h4>Parameters:</h4>
<ul>
</ul>

<h4>Ports:</h4>
<ul>
    <li>
    <pre>in       input    wire [8:0]</pre>
    </li>

    <li>
    <pre>out      output   wire [8:0]</pre>
    </li>

    <li>
    <pre>cy       output   wire</pre>
    </li>

</ul>

<p>9-bit Fast Incrementor</p>
<p>Source code:</p>
<pre><code class="lang-verilog">module Incr9 (
    input  wire [8:0] in,
    output wire [8:0] out,
    output wire       cy
);

wire [2:0] nand_2_0;
wire [5:3] nand_5_3;
wire [8:6] nand_8_6;

wire all1_2_0;
wire all1_5_0;

wire [2:0] incr_5_3;
wire [2:0] incr_8_6;

assign nand_2_0 = ~(in[0] & in[1] & in[2]);
assign nand_5_3 = ~(in[3] & in[4] & in[5]);
assign nand_8_6 = ~(in[6] & in[7] & in[8]);

assign all1_2_0 = ~nand_2_0;
assign all1_5_0 = ~(nand_2_0 | nand_5_3);
assign       cy = ~(nand_2_0 | nand_5_3 | nand_8_6);

Incr3 u_incr3_2_0(.in(in[2:0]), .out(out[2:0]));
Incr3 u_incr3_5_3(.in(in[5:3]), .out(incr_5_3));
Incr3 u_incr3_8_6(.in(in[8:6]), .out(incr_8_6));

assign out[5:3] = all1_2_0 ? incr_5_3 : in[5:3];
assign out[8:6] = all1_5_0 ? incr_8_6 : in[8:6];

endmodule</code></pre>


<hr />
<h3 id="module_blocks/JtagCoreDbg/rtl/JtagTap.sv">
Module "JtagTap", blocks/JtagCoreDbg/rtl/JtagTap.sv
</h3>

<h4>Parameters:</h4>
<ul>
</ul>

<h4>Ports:</h4>
<ul>
</ul>

<p>JTAG device TAP.
Author: Igor Lesik 2020</p>
<p>In JTAG, devices expose one or more test access ports (TAPs).
A daisy chain of TAPs is called a scan chain.</p>
<p><img alt="scan chain" src="https://en.wikipedia.org/wiki/File:Jtag_chain.svg" title="Scan chain" /></p>
<p>The TAP connector pins are: 
- TDI: Test Data In
- TDO: Test Data Out
- TCK: Test Clock
- TMS: Test Mode Select
- TRST: Test Reset (optional)</p>
<p>To use JTAG, a host is connected to the target's JTAG signals (TMS, TCK, TDI, TDO, etc.)
through some kind of JTAG adapter, which may need to handle issues like level shifting and galvanic isolation.
The adapter connects to the host using some interface such as USB, PCI, Ethernet, and so forth.</p>
<p>The host communicates with the TAPs by manipulating TMS and TDI in conjunction with TCK,
and reading results through TDO.</p>
<p>TMS/TDI/TCK transitions create the basic JTAG communication primitive
on which higher layer protocols build.</p>
<p>Source code:</p>
<pre><code class="lang-verilog">module JtagTap #(
    //
)(
    //
);

    JtagTapFsm _fsm();




endmodule</code></pre>


<hr />
<h3 id="module_blocks/JtagCoreDbg/rtl/JtagTapFsm.sv">
Module "JtagTapFsm", blocks/JtagCoreDbg/rtl/JtagTapFsm.sv
</h3>

<h4>Parameters:</h4>
<ul>
</ul>

<h4>Ports:</h4>
<ul>
    <li>
    <pre>tck      input    wire</pre>
    </li>

    <li>
    <pre>trstn    input    wire</pre>
    </li>

    <li>
    <pre>tms      input    wire</pre>
    </li>

    <li>
    <pre>state    output   reg [WIDTH-1:0]</pre>
    </li>

    <li>
    <pre>tms_reset output   reg</pre>
     5 consecutive TMS=1 causes reset
    </li>

    <li>
    <pre>state_test_logic_reset output   reg</pre>
    </li>

    <li>
    <pre>state_run_test_idle output   reg</pre>
    </li>

    <li>
    <pre>state_select_dr_scan output   reg</pre>
    </li>

    <li>
    <pre>state_capture_dr output   reg</pre>
    </li>

    <li>
    <pre>state_shift_dr output   reg</pre>
    </li>

    <li>
    <pre>state_exit1_dr output   reg</pre>
    </li>

    <li>
    <pre>state_pause_dr output   reg</pre>
    </li>

    <li>
    <pre>state_exit2_dr output   reg</pre>
    </li>

    <li>
    <pre>state_update_dr output   reg</pre>
    </li>

    <li>
    <pre>state_select_ir_scan output   reg</pre>
    </li>

    <li>
    <pre>state_capture_ir output   reg</pre>
    </li>

    <li>
    <pre>state_shift_ir output   reg</pre>
    </li>

    <li>
    <pre>state_exit1_ir output   reg</pre>
    </li>

    <li>
    <pre>state_pause_ir output   reg</pre>
    </li>

    <li>
    <pre>state_exit2_ir output   reg</pre>
    </li>

    <li>
    <pre>state_update_ir output   reg</pre>
    </li>

</ul>

<p>JTAG TAP state machine.
Author: Igor Lesik 2020</p>
<p><img alt="TAP states" src="https://upload.wikimedia.org/wikipedia/commons/1/1a/JTAG_TAP_Controller_State_Diagram.svg" title="JTAG TAP Controller State Diagram" /></p>
<p>The state machine is simple, comprising two paths: DR path and IR path.
The state machine progresses on the test clock (TCK) edge,
with the value of the test mode select (TMS) pin controlling the behavior/transition.</p>
<p><img alt="TAP states descr" src="https://www.allaboutcircuits.com/uploads/articles/jtag-part-ii-the-test-access-port-state-machine-SG-aac-image2_2.png" /></p>
<p>The Shift-DR and Shift-IR states are the main states for serial-loading data into
either data registers or the instruction register. While the state machine is in one of these states,
TMS is held LOW, until the shifting operation is complete.
The Update-DR and Update-IR states latch the data into the registers,
setting the data in the instruction register as the current instruction
(and in doing so, setting the current data register for the next cycle).</p>
<p>Source code:</p>
<pre><code class="lang-verilog">module JtagTapFsm #(
    localparam WIDTH = JTAG_TAP_STATE_VAR_WIDTH
)(
    input  wire             tck,
    input  wire             trstn,
    input  wire             tms,
    output reg  [WIDTH-1:0] state,

    output reg              tms_reset, // 5 consecutive TMS=1 causes reset

    output reg              state_test_logic_reset,
    output reg              state_run_test_idle,
    output reg              state_select_dr_scan,
    output reg              state_capture_dr,
    output reg              state_shift_dr,
    output reg              state_exit1_dr,
    output reg              state_pause_dr,
    output reg              state_exit2_dr,
    output reg              state_update_dr,
    output reg              state_select_ir_scan,
    output reg              state_capture_ir,
    output reg              state_shift_ir,
    output reg              state_exit1_ir,
    output reg              state_pause_ir,
    output reg              state_exit2_ir,
    output reg              state_update_ir
);
    assign state_test_logic_reset = (state == JTAG_TAP_STATE_TEST_LOGIC_RESET);
    assign state_run_test_idle    = (state == JTAG_TAP_STATE_RUN_TEST_IDLE);
    assign state_select_dr_scan   = (state == JTAG_TAP_STATE_SELECT_DR_SCAN);
    assign state_capture_dr       = (state == JTAG_TAP_STATE_CAPTURE_DR);
    assign state_shift_dr         = (state == JTAG_TAP_STATE_SHIFT_DR);
    assign state_exit1_dr         = (state == JTAG_TAP_STATE_EXIT1_DR);
    assign state_pause_dr         = (state == JTAG_TAP_STATE_PAUSE_DR);
    assign state_exit2_dr         = (state == JTAG_TAP_STATE_EXIT2_DR);
    assign state_update_dr        = (state == JTAG_TAP_STATE_UPDATE_DR);
    assign state_select_ir_scan   = (state == JTAG_TAP_STATE_SELECT_IR_SCAN);
    assign state_capture_ir       = (state == JTAG_TAP_STATE_CAPTURE_IR);
    assign state_shift_ir         = (state == JTAG_TAP_STATE_SHIFT_IR);
    assign state_exit1_ir         = (state == JTAG_TAP_STATE_EXIT1_IR);
    assign state_pause_ir         = (state == JTAG_TAP_STATE_PAUSE_IR);
    assign state_exit2_ir         = (state == JTAG_TAP_STATE_EXIT2_IR);
    assign state_update_ir        = (state == JTAG_TAP_STATE_UPDATE_IR);

    reg [WIDTH-1:0] next_state;

    // A transition between the states only occurs on the rising edge of TCK.
    always @(posedge tck) begin
        if (trstn == 0 || tms_reset)
            state <= JTAG_TAP_STATE_TEST_LOGIC_RESET;
        else
            state <= next_state;
    end

    // Determination of next state
    always_comb
    begin
        case (state)
            JTAG_TAP_STATE_TEST_LOGIC_RESET: begin
                next_state = (tms)? JTAG_TAP_STATE_TEST_LOGIC_RESET:JTAG_TAP_STATE_RUN_TEST_IDLE;
                end
            JTAG_TAP_STATE_RUN_TEST_IDLE: begin
                next_state = (tms)? JTAG_TAP_STATE_SELECT_DR_SCAN:JTAG_TAP_STATE_RUN_TEST_IDLE;
                end
            JTAG_TAP_STATE_SELECT_DR_SCAN: begin
                next_state = (tms)? JTAG_TAP_STATE_SELECT_IR_SCAN:JTAG_TAP_STATE_CAPTURE_DR;
                end
            JTAG_TAP_STATE_CAPTURE_DR: begin
                next_state = (tms)? JTAG_TAP_STATE_EXIT1_DR:JTAG_TAP_STATE_SHIFT_DR;
                end
            JTAG_TAP_STATE_SHIFT_DR: begin
                next_state = (tms)? JTAG_TAP_STATE_EXIT1_DR:JTAG_TAP_STATE_SHIFT_DR;
                end
            JTAG_TAP_STATE_EXIT1_DR: begin
                next_state = (tms)? JTAG_TAP_STATE_UPDATE_DR:JTAG_TAP_STATE_PAUSE_DR;
                end
            JTAG_TAP_STATE_PAUSE_DR: begin
                next_state = (tms)? JTAG_TAP_STATE_EXIT2_DR:JTAG_TAP_STATE_PAUSE_DR;
                end
            JTAG_TAP_STATE_EXIT2_DR: begin
                next_state = (tms)? JTAG_TAP_STATE_UPDATE_DR:JTAG_TAP_STATE_SHIFT_DR;
                end
            JTAG_TAP_STATE_UPDATE_DR: begin
                next_state = (tms)? JTAG_TAP_STATE_SELECT_DR_SCAN:JTAG_TAP_STATE_RUN_TEST_IDLE;
                end
            JTAG_TAP_STATE_SELECT_IR_SCAN: begin
                next_state = (tms)? JTAG_TAP_STATE_TEST_LOGIC_RESET:JTAG_TAP_STATE_CAPTURE_IR;
                end
            JTAG_TAP_STATE_CAPTURE_IR: begin
                next_state = (tms)? JTAG_TAP_STATE_EXIT1_IR:JTAG_TAP_STATE_SHIFT_IR;
                end
            JTAG_TAP_STATE_SHIFT_IR: begin
                next_state = (tms)? JTAG_TAP_STATE_EXIT1_IR:JTAG_TAP_STATE_SHIFT_IR;
                end
            JTAG_TAP_STATE_EXIT1_IR: begin
                next_state = (tms)? JTAG_TAP_STATE_UPDATE_IR:JTAG_TAP_STATE_PAUSE_IR;
                end
            JTAG_TAP_STATE_PAUSE_IR: begin
                next_state = (tms)? JTAG_TAP_STATE_EXIT2_IR:JTAG_TAP_STATE_PAUSE_IR;
                end
            JTAG_TAP_STATE_EXIT2_IR: begin
                next_state = (tms)? JTAG_TAP_STATE_UPDATE_IR:JTAG_TAP_STATE_SHIFT_IR;
                end
            JTAG_TAP_STATE_UPDATE_IR: begin
                next_state = (tms)? JTAG_TAP_STATE_SELECT_DR_SCAN:JTAG_TAP_STATE_RUN_TEST_IDLE;
                end
            default: begin // can't actually happen
                next_state = JTAG_TAP_STATE_TEST_LOGIC_RESET;
            end
        endcase
    end

    // 5 consecutive TMS=1 causes reset
    reg tms_q1, tms_q2, tms_q3, tms_q4;
    assign tms_reset = tms & tms_q1 & tms_q2 & tms_q3 & tms_q4;

    always @(posedge tck) begin
        tms_q1 <= tms;
        tms_q2 <= tms_q1;
        tms_q3 <= tms_q2;
        tms_q4 <= tms_q3;
    end

endmodule</code></pre>


<hr />
<h3 id="module_blocks/PrgCounter/rtl/PrgCounter.sv">
Module "PrgCounter", blocks/PrgCounter/rtl/PrgCounter.sv
</h3>

<h4>Parameters:</h4>
<ul>
    <li>
    ADDR_WIDTH
    </li>

    <li>
    INSN_SIZE
    </li>

    <li>
    localparam
    </li>

    <li>
    localparam
    </li>

</ul>

<h4>Ports:</h4>
<ul>
    <li>
    <pre>clk      input    wire</pre>
    </li>

    <li>
    <pre>rst      input    </pre>
    </li>

    <li>
    <pre>rst_addr input    </pre>
    </li>

    <li>
    <pre>pc_addr  output   reg [ADDR_WIDTH-1:ADDR_OFS]</pre>
    </li>

    <li>
    <pre>bit      input    </pre>
    </li>

    <li>
    <pre>ADDR_WIDTH input    </pre>
    </li>

    <li>
    <pre>1        input    </pre>
    </li>

    <li>
    <pre>ADDR_OFS input    </pre>
    </li>

    <li>
    <pre>current_pc input    </pre>
    </li>

</ul>

<p>Program Counter.</p>
<p>Author: Igor Lesik 2020
Copyright: Igor Lesik 2020</p>
<p>Assumes RISC style fixed instruction word size.</p>
<p>Source code:</p>
<pre><code class="lang-verilog">module PrgCounter #(
    parameter   ADDR_WIDTH = 32,
    parameter   INSN_SIZE  = 4,
    localparam  INSN_WIDTH = INSN_SIZE * 8,
    localparam  ADDR_OFS   = (INSN_SIZE <= 1)? 0 :
                             (INSN_SIZE <= 2)? 1 :
                             (INSN_SIZE <= 4)? 2 :
                             (INSN_SIZE <= 8)? 3 :
                             (INSN_SIZE <=16)? 4 : -1
)(
    input  wire                         clk,
    input  wire                         rst,
    input  wire [ADDR_WIDTH-1:ADDR_OFS] rst_addr,
    output reg  [ADDR_WIDTH-1:ADDR_OFS] pc_addr
);

    reg rst_delay1;

    always @ (posedge clk)
    begin
        pc_addr <= next_pc(pc_addr, rst_delay1, rst_addr);
        rst_delay1 <= rst;
    end

    // Calculate next PC.
    //
    function bit [ADDR_WIDTH-1:ADDR_OFS] next_pc(
        input bit [ADDR_WIDTH-1:ADDR_OFS] current_pc,
        input bit rst,
        input bit [ADDR_WIDTH-1:ADDR_OFS] rst_addr
    );
        if (rst) begin
            next_pc = rst_addr;
        end
        else begin
            next_pc = current_pc + 1;
        end

        //$display("PC: %x, rst: %d", next_pc, rst);
    endfunction

endmodule</code></pre>


<hr />
<h3 id="module_blocks/ShiftReg/rtl/ShiftReg.sv">
Module "ShiftReg", blocks/ShiftReg/rtl/ShiftReg.sv
</h3>

<h4>Parameters:</h4>
<ul>
    <li>
    WIDTH
    </li>

</ul>

<h4>Ports:</h4>
<ul>
    <li>
    <pre>clk      input    wire</pre>
    </li>

    <li>
    <pre>srl_prl  input    wire</pre>
    </li>

    <li>
    <pre>srl_in   input    wire</pre>
    </li>

    <li>
    <pre>prl_in   input    wire [WIDTH-1:0]</pre>
    </li>

    <li>
    <pre>srl_out  output   wire</pre>
    </li>

    <li>
    <pre>prl_out  output   wire [WIDTH-1:0]</pre>
    </li>

</ul>

<p>@file
 @brief  Shift register
 @author Igor Lesik 2020</p>
<p>parallel load
      +                           shift reg Nth bit
      |        mux                      ^
      |       +----+      +---------+   |
      |       |    |      |         |   |
      +-------+ 0  |      |  DFF    |   |
              |    |      |         |   |
              |    +------+         +---+---&gt;
    +---------+ 1  |      |         |   to next
  prev stage  |    |      |         |   stage
  output      +-+--+      +---------+
                |
                + serial/parallel selector</p>
<p>Source code:</p>
<pre><code class="lang-verilog">module ShiftReg #(
    parameter WIDTH = 8
)(
    input  wire             clk,
    input  wire             srl_prl,
    input  wire             srl_in,
    input  wire [WIDTH-1:0] prl_in,
    output wire             srl_out,
    output wire [WIDTH-1:0] prl_out
);

wire [WIDTH-1:0] ff_in;
wire [WIDTH-1:0] srls_in;

assign srl_out = prl_out[WIDTH-1];
assign srls_in[0] = srl_in;
assign srls_in[WIDTH-1:1] = prl_out[WIDTH-2:0];

Mux2#(.WIDTH(WIDTH)) mux_(
    .in1(prl_in),
    .in2(srls_in),
    .sel(srl_prl),
    .out(ff_in)
);

Dff#(.WIDTH(WIDTH)) ff_(
    .clk(clk),
    .in(ff_in),
    .out(prl_out)
);

endmodule</code></pre>


<hr />
<h3 id="module_blocks/SimRAM/rtl/SimRAM.sv">
Module "SimRAM", blocks/SimRAM/rtl/SimRAM.sv
</h3>

<h4>Parameters:</h4>
<ul>
    <li>
    DATA_SIZE
    </li>

    <li>
    1
    </li>

    <li>
    2
    </li>

    <li>
    4
    </li>

    <li>
    ADDR_WIDTH
    </li>

    <li>
    MEM_SIZE
    </li>

</ul>

<h4>Ports:</h4>
<ul>
    <li>
    <pre>clk      input    wire</pre>
    </li>

    <li>
    <pre>rd_en    input    wire</pre>
    </li>

    <li>
    <pre>rd_addr  input    wire [ADDR_WIDTH-1:0]</pre>
    </li>

    <li>
    <pre>wr_en    input    wire</pre>
    </li>

    <li>
    <pre>wr_addr  input    wire [ADDR_WIDTH-1:0]</pre>
    </li>

    <li>
    <pre>wr_data  input    wire [DATA_WIDTH-1:0]</pre>
    </li>

    <li>
    <pre>rd_data  output   reg [DATA_WIDTH-1:0]</pre>
    </li>

</ul>

<p>Verilog simulation RAM model.</p>
<p>Author: Igor Lesik 2013-2020</p>
<p>Source code:</p>
<pre><code class="lang-verilog">module SimRAM #(
    parameter  DATA_SIZE  = 1, // 1-byte, 2-16bits, 4-32bits word
    localparam DATA_WIDTH = 8 * DATA_SIZE,
    parameter  ADDR_WIDTH = 8,
    parameter  MEM_SIZE   = 2**ADDR_WIDTH
)(
    input  wire                  clk,
    input  wire                  rd_en,
    input  wire [ADDR_WIDTH-1:0] rd_addr,
    input  wire                  wr_en,
    input  wire [ADDR_WIDTH-1:0] wr_addr,
    input  wire [DATA_WIDTH-1:0] wr_data,
    output reg  [DATA_WIDTH-1:0] rd_data
);

    reg [DATA_WIDTH-1:0] ram [MEM_SIZE];

    localparam VLOG_HEX_FORMAT = 0;
    localparam VLOG_BIN_FORMAT = 1;
    //TODO localparam SREC_FORMAT = 2;

    // Load memory contents from a file.
    //
    function int load(string filename, int format);
        if (format == VLOG_HEX_FORMAT)
            $readmemh(filename, ram);
        else if (format == VLOG_BIN_FORMAT)
            $readmemb(filename, ram);
        else
            return 0;

        return 1;
    endfunction


    always @ (posedge clk)
    begin
        if (wr_en) begin
            ram[integer'(wr_addr)] <= wr_data;
        end

        if (rd_en) begin
            //$display("ROM[%h]=%h", integer'(addr)+i, rom[integer'(addr)+i]);
            rd_data <= ram[integer'(rd_addr)];
            if (wr_en && rd_addr == wr_addr) begin
                assert(0);//FIXME
            end
        end
    end

endmodule</code></pre>


<hr />
<h3 id="module_blocks/SimROM/rtl/SimROM.sv">
Module "SimROM", blocks/SimROM/rtl/SimROM.sv
</h3>

<h4>Parameters:</h4>
<ul>
    <li>
    DATA_SIZE
    </li>

    <li>
    1
    </li>

    <li>
    2
    </li>

    <li>
    4
    </li>

    <li>
    ADDR_WIDTH
    </li>

    <li>
    MEM_SIZE
    </li>

</ul>

<h4>Ports:</h4>
<ul>
    <li>
    <pre>clk      input    wire</pre>
    </li>

    <li>
    <pre>addr     input    wire [ADDR_WIDTH-1:0]</pre>
    </li>

    <li>
    <pre>data     output   reg [DATA_WIDTH-1:0]</pre>
    </li>

</ul>

<p>Verilog simulation ROM model.</p>
<p>Author: Igor Lesik 2013-2020</p>
<p>Verilog binary format example:</p>
<pre>
@003
00000011
00000100
@005
00000101
</pre>

<p>Verilog hex format example:</p>
<pre>
@003
3
4
</pre>
<p>Source code:</p>
<pre><code class="lang-verilog">module SimROM #(
    parameter  DATA_SIZE  = 1, // 1-byte, 2-16bits, 4-32bits word
    localparam DATA_WIDTH = 8 * DATA_SIZE,
    parameter  ADDR_WIDTH = 8,
    parameter  MEM_SIZE   = 2**ADDR_WIDTH
)(
    input  wire                  clk,
    input  wire [ADDR_WIDTH-1:0] addr,
    output reg  [DATA_WIDTH-1:0] data
);

    reg [DATA_WIDTH-1:0] rom [MEM_SIZE];

    localparam VLOG_HEX_FORMAT = 0;
    localparam VLOG_BIN_FORMAT = 1;
    //TODO localparam SREC_FORMAT = 2;

    function int load(string filename, int format);
        if (format == VLOG_HEX_FORMAT)
            $readmemh(filename, rom);
        else if (format == VLOG_BIN_FORMAT)
            $readmemb(filename, rom);
        else
            return 0;

        return 1;
    endfunction

    always @ (posedge clk)
    begin
        //$display("ROM[%h]=%h", integer'(addr)+i, rom[integer'(addr)+i]);
        data <= rom[integer'(addr)];
    end

endmodule</code></pre>


<hr />
<h3 id="module_lib/gates/builtin/INV.sv">
Module "INV", lib/gates/builtin/INV.sv
</h3>

<h4>Parameters:</h4>
<ul>
    <li>
    WIDTH
    </li>

</ul>

<h4>Ports:</h4>
<ul>
    <li>
    <pre>in       input    wire [WIDTH-1:0]</pre>
    </li>

    <li>
    <pre>out      output   wire [WIDTH-1:0]</pre>
     out = ~in
    </li>

</ul>

<p>Inverter.</p>
<script type="WaveDrom">
{ assign:[
  ["out",
    ["~", "in"]
  ]
]}
</script>

<p>Wrapper around Inv.</p>
<p>Source code:</p>
<pre><code class="lang-verilog">module INV #(
    parameter WIDTH = 1
)(
    input  wire [WIDTH-1:0] in,
    output wire [WIDTH-1:0] out // out = ~in
);
    Inv#(WIDTH) inv_(.in(in), .out(out));
endmodule</code></pre>


<hr />
<h3 id="module_lib/gates/builtin/Inv.sv">
Module "Inv", lib/gates/builtin/Inv.sv
</h3>

<h4>Parameters:</h4>
<ul>
    <li>
    WIDTH
    </li>

</ul>

<h4>Ports:</h4>
<ul>
    <li>
    <pre>in       input    wire [WIDTH-1:0]</pre>
    </li>

    <li>
    <pre>out      output   wire [WIDTH-1:0]</pre>
     out = ~in
    </li>

</ul>

<p>Inverter.</p>
<script type="WaveDrom">
{ assign:[
  ["out",
    ["~", "in"]
  ]
]}
</script>
<p>Source code:</p>
<pre><code class="lang-verilog">module Inv #(
    parameter WIDTH = 1
)(
    input  wire [WIDTH-1:0] in,
    output wire [WIDTH-1:0] out // out = ~in
);
    not /*(strength)*/ /*#(2 delays)*/ not_(out, in);

endmodule</code></pre>


<hr />
<h3 id="module_lib/gates/builtin/MUX2.sv">
Module "MUX2", lib/gates/builtin/MUX2.sv
</h3>

<h4>Parameters:</h4>
<ul>
    <li>
    WIDTH
    </li>

</ul>

<h4>Ports:</h4>
<ul>
    <li>
    <pre>in1      input    wire [WIDTH-1:0]</pre>
    </li>

    <li>
    <pre>in2      input    wire [WIDTH-1:0]</pre>
    </li>

    <li>
    <pre>sel      input    wire</pre>
    </li>

    <li>
    <pre>out      output   wire [WIDTH-1:0]</pre>
    </li>

</ul>

<p>2:1 Multiplexer</p>
<p>Source code:</p>
<pre><code class="lang-verilog">module MUX2 #(
    parameter WIDTH = 1
)(
    input  wire [WIDTH-1:0]  in1,
    input  wire [WIDTH-1:0]  in2,
    input  wire              sel,
    output wire [WIDTH-1:0]  out
);

    Mux2#(WIDTH) mux2_(.in1(in1), .in2(in2), .sel(sel), .out(out));

endmodule</code></pre>


<hr />
<h3 id="module_lib/gates/builtin/Mux2.sv">
Module "Mux2", lib/gates/builtin/Mux2.sv
</h3>

<h4>Parameters:</h4>
<ul>
    <li>
    WIDTH
    </li>

</ul>

<h4>Ports:</h4>
<ul>
    <li>
    <pre>in1      input    wire [WIDTH-1:0]</pre>
    </li>

    <li>
    <pre>in2      input    wire [WIDTH-1:0]</pre>
    </li>

    <li>
    <pre>sel      input    wire</pre>
    </li>

    <li>
    <pre>out      output   wire [WIDTH-1:0]</pre>
    </li>

</ul>

<p>Multiplexer made with NAND</p>
<p>Author: Igor Lesik 2020.</p>
<script type="WaveDrom">
{ assign:[
  ["out",
    ["~&",
      ["~&", "in1", "sel"],
      ["~&", "in2", "~sel"]
    ]
  ]
]}
</script>

<pre> 
                 +------+
                 |      |
 in1 +-----------+ NAND |
                 |      |o+-+    +------+
 sel +-----+-----+      |   |    |      |
           |     |      |   |    |      |
           |     +------+   +----+ NAND |
           |                     |      |o+----+ out
           |     +------+   +----+      |
           |     |      |   |    |      |
           +---+o| NAND |   |    |      |
                 |      |o+-+    +------+
 in2 +-----------+      |
                 |      |
                 +------+
 </pre>
<p>Source code:</p>
<pre><code class="lang-verilog">module Mux2 #(
    parameter WIDTH = 1
)(
    input  wire [WIDTH-1:0]  in1,
    input  wire [WIDTH-1:0]  in2,
    input  wire              sel,
    output wire [WIDTH-1:0]  out
);

    wire [WIDTH-1:0] o1, o2;
    NAND2#(WIDTH) nand1_(.out(o1), .in1(in1), .in2({WIDTH{sel}}));
    NAND2#(WIDTH) nand2_(.out(o2), .in1(in2), .in2({WIDTH{~sel}}));
    NAND2#(WIDTH) nand3_(.out(out), .in1(o1), .in2(o2));

endmodule</code></pre>


<hr />
<h3 id="module_lib/gates/builtin/NAND2.sv">
Module "NAND2", lib/gates/builtin/NAND2.sv
</h3>

<h4>Parameters:</h4>
<ul>
    <li>
    WIDTH
    </li>

</ul>

<h4>Ports:</h4>
<ul>
    <li>
    <pre>in1      input    wire [WIDTH-1:0]</pre>
    </li>

    <li>
    <pre>in2      input    wire [WIDTH-1:0]</pre>
    </li>

    <li>
    <pre>out      output   wire [WIDTH-1:0]</pre>
    </li>

</ul>

<p>2-input NAND.</p>
<script type="WaveDrom">
{ assign:[
  ["out",
    ["~&", "in1", "in2"]
  ]
]}
</script>
<p>Source code:</p>
<pre><code class="lang-verilog">module NAND2 #(
    parameter WIDTH = 1
)(
    input  wire [WIDTH-1:0] in1,
    input  wire [WIDTH-1:0] in2,
    output wire [WIDTH-1:0] out
);

    NAnd2#(WIDTH) nand_(.in1(in1), .in2(in2), .out(out));

endmodule</code></pre>


<hr />
<h3 id="module_lib/gates/builtin/NAnd2.sv">
Module "NAnd2", lib/gates/builtin/NAnd2.sv
</h3>

<h4>Parameters:</h4>
<ul>
    <li>
    WIDTH
    </li>

</ul>

<h4>Ports:</h4>
<ul>
    <li>
    <pre>in1      input    wire [WIDTH-1:0]</pre>
    </li>

    <li>
    <pre>in2      input    wire [WIDTH-1:0]</pre>
    </li>

    <li>
    <pre>out      output   wire [WIDTH-1:0]</pre>
    </li>

</ul>

<p>2-input NAND.</p>
<script type="WaveDrom">
{ assign:[
  ["out",
    ["~&", "in1", "in2"]
  ]
]}
</script>
<p>Source code:</p>
<pre><code class="lang-verilog">module NAnd2 #(
    parameter WIDTH = 1
)(
    input  wire [WIDTH-1:0] in1,
    input  wire [WIDTH-1:0] in2,
    output wire [WIDTH-1:0] out
);

    nand /*(strength)*/ /*#(3 delays)*/ nand_(out, in1, in2);

endmodule</code></pre>


<hr />
<h3 id="module_lib/gates/cmos/AND2.sv">
Module "AND2", lib/gates/cmos/AND2.sv
</h3>

<h4>Parameters:</h4>
<ul>
</ul>

<h4>Ports:</h4>
<ul>
    <li>
    <pre>in1      input    wire</pre>
    </li>

    <li>
    <pre>in2      input    wire</pre>
    </li>

    <li>
    <pre>out      output   wire</pre>
    </li>

</ul>

<p>2-input AND.</p>
<script type="WaveDrom">
{ assign:[
  ["out",
    ["&", "in1", "in2"]
  ]
]}
</script>
<p>Source code:</p>
<pre><code class="lang-verilog">module AND2 (
    input  wire in1,
    input  wire in2,
    output wire out
);
    wire nand_output;
    NAnd2 nand2_(.in1(in1), .in2(in2), .out(nand_output));
    Inv   inv_  (.in(nand_output), .out(out));

endmodule</code></pre>


<hr />
<h3 id="module_lib/gates/cmos/INV.sv">
Module "INV", lib/gates/cmos/INV.sv
</h3>

<h4>Parameters:</h4>
<ul>
    <li>
    WIDTH
    </li>

</ul>

<h4>Ports:</h4>
<ul>
    <li>
    <pre>in       input    wire [WIDTH-1:0]</pre>
    </li>

    <li>
    <pre>out      output   wire [WIDTH-1:0]</pre>
     out = ~in
    </li>

</ul>

<p>Inverter.</p>
<script type="WaveDrom">
{ assign:[
  ["out",
    ["~", "in"]
  ]
]}
</script>

<p>Uses Inv.</p>
<p>Source code:</p>
<pre><code class="lang-verilog">module INV #(
    parameter WIDTH = 1
)(
    input  wire [WIDTH-1:0] in,
    output wire [WIDTH-1:0] out // out = ~in
);
    genvar i;
    generate
    for (i = 0; i < WIDTH; i = i + 1) begin
        Inv inv_(.in(in[i]), .out(out[i]));
    end
    endgenerate

endmodule</code></pre>


<hr />
<h3 id="module_lib/gates/cmos/Inv.sv">
Module "Inv", lib/gates/cmos/Inv.sv
</h3>

<h4>Parameters:</h4>
<ul>
</ul>

<h4>Ports:</h4>
<ul>
    <li>
    <pre>in       input    wire</pre>
    </li>

    <li>
    <pre>out      output   wire</pre>
     out = ~in
    </li>

</ul>

<p>CMOS Inverter gate.</p>
<script type="WaveDrom">
{ assign:[
  ["out",
    ["~", "in"]
  ]
]}
</script>

<p>Use Verilog keywords <code>pmos</code> and <code>nmos</code> to define 2 transistors:</p>
<div class="codehilite"><pre><span></span><code> <span class="k">pmos</span> <span class="n">p1</span> <span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">vdd</span><span class="p">,</span> <span class="n">in</span><span class="p">);</span> <span class="c1">// out = HI(vdd) if in is LO</span>
 <span class="k">nmos</span> <span class="n">n1</span> <span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">gnd</span><span class="p">,</span> <span class="n">in</span><span class="p">);</span> <span class="c1">// out = LO(gnd) if in is HI</span>
</code></pre></div>

<p>See book by Yamin Li, Computer principles and design in Verilog HDL.</p>
<pre>
          +-------+-----+ vdd
                  |
              +   |
            + +---+
      +----o| |      p1
      |     + +---+
      |       +   |
      |           |
 +----+           +------+
      |           |
      |       +   |
      |     + +---+
      +-----+ |     n1
            + +---+
              +   |
                  |
                  |
        +---------+----+ gnd
</pre>
<p>Source code:</p>
<pre><code class="lang-verilog">module Inv (
    input  wire in,
    output wire out // out = ~in
);
    supply1 vdd; // logic 1 (power)
    supply0 gnd; // logic 0 (ground)

    // pmos (drain, source, gate);
    pmos p1 (out, vdd, in);

    // nmos (drain, source, gate);
    nmos n1 (out, gnd, in);

endmodule</code></pre>


<hr />
<h3 id="module_lib/gates/cmos/MUX2.sv">
Module "MUX2", lib/gates/cmos/MUX2.sv
</h3>

<h4>Parameters:</h4>
<ul>
    <li>
    WIDTH
    </li>

</ul>

<h4>Ports:</h4>
<ul>
    <li>
    <pre>in1      input    wire [WIDTH-1:0]</pre>
    </li>

    <li>
    <pre>in2      input    wire [WIDTH-1:0]</pre>
    </li>

    <li>
    <pre>sel      input    wire</pre>
    </li>

    <li>
    <pre>out      output   wire [WIDTH-1:0]</pre>
    </li>

</ul>

<p>2:1 Multiplexer.</p>
<p>Source code:</p>
<pre><code class="lang-verilog">module MUX2  #(
    parameter WIDTH = 1
)(
    input  wire [WIDTH-1:0] in1,
    input  wire [WIDTH-1:0] in2,
    input  wire             sel,
    output wire [WIDTH-1:0] out
);

    genvar i;
    generate
    for (i = 0; i < WIDTH; i = i + 1) begin
        Mux2 mux2_(.in1(in1[i]), .in2(in2[i]), .sel(sel), .out(out[i]));
    end
    endgenerate

endmodule</code></pre>


<hr />
<h3 id="module_lib/gates/cmos/Mux2.sv">
Module "Mux2", lib/gates/cmos/Mux2.sv
</h3>

<h4>Parameters:</h4>
<ul>
</ul>

<h4>Ports:</h4>
<ul>
    <li>
    <pre>in1      input    wire</pre>
    </li>

    <li>
    <pre>in2      input    wire</pre>
    </li>

    <li>
    <pre>sel      input    wire</pre>
    </li>

    <li>
    <pre>out      output   wire</pre>
    </li>

</ul>

<p>2:1 Multiplexer.</p>
<pre>
   ---------+-------------+------ vdd
            |             |
   in1 +--o| p1  in2 +--o| p3
            |             |      pmos is open when gate 0
            |             |
  ~sel +--o| p2  sel +--o| p4
            |             |
            +-------------+---------INV----->
            |             |
   sel +---| n1 ~sel +--o| n3
            |             |      nmos is open when gate 1
            |             |
   in1 +---| n2  in2 +---| n4
            |             |
            |             |
          --+-------------+------ gnd
</pre>
<p>Source code:</p>
<pre><code class="lang-verilog">module Mux2 (
    input  wire in1,
    input  wire in2,
    input  wire sel,
    output wire out
);

    supply1 vdd;
    supply0 gnd;

    wire nsel;
    INV inv_sel_(.in(sel), .out(nsel));

    wire o;
    INV inv_out_(.in(o), .out(out));

    wire p1_p2, p3_p4, n1_n2, n3_n4;

    // pmos drain source gate
    pmos p1(p1_p2,  vdd,   in1);
    pmos p2(o,    p1_p2,   nsel);

    pmos p3(p3_p4,  vdd,   in2);
    pmos p4(o,    p3_p4,   sel);

    // nmos drain source gate
    nmos n1(o,    n1_n2,   sel);
    nmos n2(n1_n2,  gnd,   in1);

    nmos n3(o,    n3_n4,  nsel);
    nmos n4(n3_n4,  gnd,   in2);

endmodule</code></pre>


<hr />
<h3 id="module_lib/gates/cmos/NAND2.sv">
Module "NAND2", lib/gates/cmos/NAND2.sv
</h3>

<h4>Parameters:</h4>
<ul>
    <li>
    WIDTH
    </li>

</ul>

<h4>Ports:</h4>
<ul>
    <li>
    <pre>in1      input    wire [WIDTH-1:0]</pre>
    </li>

    <li>
    <pre>in2      input    wire [WIDTH-1:0]</pre>
    </li>

    <li>
    <pre>out      output   wire [WIDTH-1:0]</pre>
    </li>

</ul>

<p>2-input NAND.</p>
<script type="WaveDrom">
{ assign:[
  ["out",
    ["~&", "in1", "in2"]
  ]
]}
</script>

<p>Uses NAnd2</p>
<p>Source code:</p>
<pre><code class="lang-verilog">module NAND2  #(
    parameter WIDTH = 1
)(
    input  wire [WIDTH-1:0] in1,
    input  wire [WIDTH-1:0] in2,
    output wire [WIDTH-1:0] out
);

    genvar i;
    generate
    for (i = 0; i < WIDTH; i = i + 1) begin
        NAnd2 nand2_(.in1(in1[i]), .in2(in2[i]), .out(out[i]));
    end
    endgenerate

endmodule</code></pre>


<hr />
<h3 id="module_lib/gates/cmos/NAnd2.sv">
Module "NAnd2", lib/gates/cmos/NAnd2.sv
</h3>

<h4>Parameters:</h4>
<ul>
</ul>

<h4>Ports:</h4>
<ul>
    <li>
    <pre>in1      input    wire</pre>
    </li>

    <li>
    <pre>in2      input    wire</pre>
    </li>

    <li>
    <pre>out      output   wire</pre>
    </li>

</ul>

<p>2-input NAND.</p>
<script type="WaveDrom">
{ assign:[
  ["out",
    ["~&", "in1", "in2"]
  ]
]}
</script>

<pre>
   ---------+-------------+------ vdd
            |             |
      +--o| p1      +--o| p2
      |     |       |     |
      |     +-------------+------ out
      |             |     |
 in1 -+-----------------| n1
                    |     |
 in2 ---------------+---| n2
                          |
                  --------+------ gnd
</pre>
<p>Source code:</p>
<pre><code class="lang-verilog">module NAnd2 (
    input  wire in1,
    input  wire in2,
    output wire out
);

    supply1 vdd;
    supply0 gnd;

    wire w_n; // connects 2 nmos transistors

    // pmos drain source gate
    pmos p1(out,  vdd,   in1);
    pmos p2(out,  vdd,   in2);

    // nmos drain source gate
    nmos n1(out,  w_n,   in1);
    nmos n2(w_n,  gnd,   in2);

endmodule</code></pre>


<hr />
<h3 id="module_lib/gates/cmos/NOR2.sv">
Module "NOR2", lib/gates/cmos/NOR2.sv
</h3>

<h4>Parameters:</h4>
<ul>
</ul>

<h4>Ports:</h4>
<ul>
    <li>
    <pre>in1      input    wire</pre>
    </li>

    <li>
    <pre>in2      input    wire</pre>
    </li>

    <li>
    <pre>out      output   wire</pre>
    </li>

</ul>

<p>2-input NOR</p>
<script type="WaveDrom">
{ assign:[
  ["out",
    ["~|", "in1", "in2"]
  ]
]}
</script>

<p>Wrapper around NOr2 </p>
<p>Source code:</p>
<pre><code class="lang-verilog">module NOR2 (
    input  wire in1,
    input  wire in2,
    output wire out
);

    NOr2 nor2_(.in1(in1), .in2(in2), .out(out));

endmodule</code></pre>


<hr />
<h3 id="module_lib/gates/cmos/NOr2.sv">
Module "NOr2", lib/gates/cmos/NOr2.sv
</h3>

<h4>Parameters:</h4>
<ul>
</ul>

<h4>Ports:</h4>
<ul>
    <li>
    <pre>in1      input    wire</pre>
    </li>

    <li>
    <pre>in2      input    wire</pre>
    </li>

    <li>
    <pre>out      output   wire</pre>
    </li>

</ul>

<p>2-input NOR</p>
<script type="WaveDrom">
{ assign:[
  ["out",
    ["~|", "in1", "in2"]
  ]
]}
</script>

<pre> 
             -------------+------ vdd
                          |
 in1 ---+--------------o| p1
        |                 |
 in2 -------------+----o| p2
        |         |       |
        |    +------------+------ out
        |    |    |       |
        +--| n1   +-----| n2
             |            |
          ---+------------+---- gnd
</pre>
<p>Source code:</p>
<pre><code class="lang-verilog">module NOr2 (
    input  wire in1,
    input  wire in2,
    output wire out
);

    supply1 vdd;
    supply0 gnd;

    wire w_p; // connects 2 pmos transistors

    // nmos drain source gate
    pmos n1(out,  gnd,   in1);
    pmos n2(out,  gnd,   in2);

    // pmos drain source gate
    pmos p1(w_p,  vdd,   in1);
    pmos p2(out,  w_p,   in2);

endmodule</code></pre>


<hr />
<h3 id="module_lib/gates/generic/AOI22.sv">
Module "AOI22", lib/gates/generic/AOI22.sv
</h3>

<h4>Parameters:</h4>
<ul>
    <li>
    WIDTH
    </li>

</ul>

<h4>Ports:</h4>
<ul>
    <li>
    <pre>in1      input    wire [WIDTH-1:0]</pre>
     to be AND-ed with in2
    </li>

    <li>
    <pre>in2      input    wire [WIDTH-1:0]</pre>
     to be AND-ed with in1
    </li>

    <li>
    <pre>in3      input    wire [WIDTH-1:0]</pre>
     to be AND-ed with in4
    </li>

    <li>
    <pre>in4      input    wire [WIDTH-1:0]</pre>
     to be AND-ed with in3
    </li>

    <li>
    <pre>out      output   wire [WIDTH-1:0]</pre>
     NOR the results of two ANDs
    </li>

</ul>

<p>Complex gate And-Or-Invertor.</p>
<pre>
 in1 ----------+--\
               AND +----+
 in2 ----------+--/|    |
                   |NOR |o-----
 in3 ----------+--\|    |
               AND +----+
 in4 ----------+--/
</pre>

<script type="WaveDrom">
{ assign:[
  ["out",
    ["~|",
      ["&", "in1", "in2"],
      ["&", "in3", "in4"]
    ]
  ]
]}
</script>
<p>Source code:</p>
<pre><code class="lang-verilog">module AOI22 #(
    parameter WIDTH = 1
)(
    input  wire [WIDTH-1:0] in1, // to be AND-ed with in2
    input  wire [WIDTH-1:0] in2, // to be AND-ed with in1
    input  wire [WIDTH-1:0] in3, // to be AND-ed with in4
    input  wire [WIDTH-1:0] in4, // to be AND-ed with in3
    output wire [WIDTH-1:0] out  // NOR the results of two ANDs
);

    assign out = ~((in1 & in2) | (in3 & in4));

endmodule</code></pre>


<hr />
<h3 id="module_lib/gates/generic/Dff.sv">
Module "Dff", lib/gates/generic/Dff.sv
</h3>

<h4>Parameters:</h4>
<ul>
    <li>
    WIDTH
    </li>

</ul>

<h4>Ports:</h4>
<ul>
    <li>
    <pre>clk      input    wire</pre>
    </li>

    <li>
    <pre>in       input    wire [WIDTH-1:0]</pre>
    </li>

    <li>
    <pre>out      output   reg [WIDTH-1:0]</pre>
    </li>

</ul>

<p>@file
 @brief     Rising edge triggered D Flip Flop
 @author    Igor Lesik
 @copyright Igor Lesik 2014</p>
<p>Source code:</p>
<pre><code class="lang-verilog">module Dff #(
    parameter WIDTH = 1
)(
    input  wire             clk,
    input  wire [WIDTH-1:0] in,
    output reg  [WIDTH-1:0] out
);
  
always_ff @(posedge clk)
    out[WIDTH-1:0] <= in[WIDTH-1:0];

`ifdef DFF_RANDOMIZE_INITIAL_VALUE
initial begin
    out = $urandom_range(2**WIDTH - 1, 0);
end
`endif

endmodule</code></pre>


<hr />
<h3 id="module_lib/gates/generic/INV.sv">
Module "INV", lib/gates/generic/INV.sv
</h3>

<h4>Parameters:</h4>
<ul>
    <li>
    WIDTH
    </li>

</ul>

<h4>Ports:</h4>
<ul>
    <li>
    <pre>in       input    wire [WIDTH-1:0]</pre>
     to be inverted
    </li>

    <li>
    <pre>out      output   wire [WIDTH-1:0]</pre>
     out is inverted in
    </li>

</ul>

<p>Inverter.</p>
<script type="WaveDrom">
{ assign:[
  ["out",
    ["~", "in"]
  ]
]}
</script>
<p>Source code:</p>
<pre><code class="lang-verilog">module INV #(
    parameter WIDTH = 1
)(
    input  wire [WIDTH-1:0] in,  // to be inverted
    output wire [WIDTH-1:0] out  // out is inverted in
);

    assign out = ~in;

endmodule</code></pre>


<hr />
<h3 id="module_lib/gates/generic/MUX2.sv">
Module "MUX2", lib/gates/generic/MUX2.sv
</h3>

<h4>Parameters:</h4>
<ul>
    <li>
    WIDTH
    </li>

</ul>

<h4>Ports:</h4>
<ul>
    <li>
    <pre>in1      input    wire [WIDTH-1:0]</pre>
    </li>

    <li>
    <pre>in2      input    wire [WIDTH-1:0]</pre>
    </li>

    <li>
    <pre>sel      input    wire</pre>
    </li>

    <li>
    <pre>out      output   wire [WIDTH-1:0]</pre>
    </li>

</ul>

<p>2:1 Multiplexer</p>
<p>Source code:</p>
<pre><code class="lang-verilog">module MUX2 #(
    parameter WIDTH = 1
)(
    input  wire [WIDTH-1:0]  in1,
    input  wire [WIDTH-1:0]  in2,
    input  wire              sel,
    output wire [WIDTH-1:0]  out
);

    Mux2#(WIDTH) mux2_(.in1(in1), .in2(in2), .sel(sel), .out(out));

endmodule</code></pre>


<hr />
<h3 id="module_lib/gates/generic/MUX4.sv">
Module "MUX4", lib/gates/generic/MUX4.sv
</h3>

<h4>Parameters:</h4>
<ul>
    <li>
    WIDTH
    </li>

</ul>

<h4>Ports:</h4>
<ul>
    <li>
    <pre>in1      input    wire [WIDTH-1:0]</pre>
    </li>

    <li>
    <pre>in2      input    wire [WIDTH-1:0]</pre>
    </li>

    <li>
    <pre>in3      input    wire [WIDTH-1:0]</pre>
    </li>

    <li>
    <pre>in4      input    wire [WIDTH-1:0]</pre>
    </li>

    <li>
    <pre>sel      input    wire [1:0]</pre>
    </li>

    <li>
    <pre>out      output   wire [WIDTH-1:0]</pre>
    </li>

</ul>

<p>4:1 Multiplexer</p>
<p>Source code:</p>
<pre><code class="lang-verilog">module MUX4 #(
    parameter WIDTH = 1
)(
    input  wire [WIDTH-1:0]  in1,
    input  wire [WIDTH-1:0]  in2,
    input  wire [WIDTH-1:0]  in3,
    input  wire [WIDTH-1:0]  in4,
    input  wire [1:0]        sel,
    output wire [WIDTH-1:0]  out
);

    Mux4#(WIDTH) mux4_(.in1, .in2, .in3, .in4, .sel, .out);

endmodule</code></pre>


<hr />
<h3 id="module_lib/gates/generic/Mux2.sv">
Module "Mux2", lib/gates/generic/Mux2.sv
</h3>

<h4>Parameters:</h4>
<ul>
    <li>
    WIDTH
    </li>

</ul>

<h4>Ports:</h4>
<ul>
    <li>
    <pre>in1      input    wire [WIDTH-1:0]</pre>
    </li>

    <li>
    <pre>in2      input    wire [WIDTH-1:0]</pre>
    </li>

    <li>
    <pre>sel      input    wire</pre>
    </li>

    <li>
    <pre>out      output   wire [WIDTH-1:0]</pre>
    </li>

</ul>

<p>2:1 Multiplexer.</p>
<p>Author: Igor Lesik 2014.</p>
<!--script type="WaveDrom">
{ assign:[
  ["out",
    ["?", "sel", "in1", "in2"]
  ]
]}
</script-->

<pre>
          +-----+
in1 ------| 1   |
          | MUX |--- out   
in2 ------| 0   |
          +--+--+
        sel  |
</pre>
<p>Source code:</p>
<pre><code class="lang-verilog">module Mux2 #(
    parameter WIDTH = 1
)(
    input  wire [WIDTH-1:0]  in1,
    input  wire [WIDTH-1:0]  in2,
    input  wire              sel,
    output wire [WIDTH-1:0]  out
);

    assign out = (sel == 1) ? in1 : in2;

endmodule</code></pre>


<hr />
<h3 id="module_lib/gates/generic/Mux4.sv">
Module "Mux4", lib/gates/generic/Mux4.sv
</h3>

<h4>Parameters:</h4>
<ul>
    <li>
    WIDTH
    </li>

</ul>

<h4>Ports:</h4>
<ul>
    <li>
    <pre>in1      input    wire [WIDTH-1:0]</pre>
    </li>

    <li>
    <pre>in2      input    wire [WIDTH-1:0]</pre>
    </li>

    <li>
    <pre>in3      input    wire [WIDTH-1:0]</pre>
    </li>

    <li>
    <pre>in4      input    wire [WIDTH-1:0]</pre>
    </li>

    <li>
    <pre>sel      input    wire [1:0]</pre>
    </li>

    <li>
    <pre>out      output   wire [WIDTH-1:0]</pre>
    </li>

</ul>

<p>4:1 Multiplexer
Author: Igor Lesik 2014</p>
<p>Source code:</p>
<pre><code class="lang-verilog">module Mux4 #(
    parameter WIDTH = 1
)(
    input  wire [WIDTH-1:0]  in1,
    input  wire [WIDTH-1:0]  in2,
    input  wire [WIDTH-1:0]  in3,
    input  wire [WIDTH-1:0]  in4,
    input  wire [1:0]        sel,
    output wire [WIDTH-1:0]  out
);

assign out = (sel == 0) ? in1 :
             (sel == 1) ? in2 :
             (sel == 2) ? in3 : in4;
/*
 assign Z =    (~S1 & ~S0 & I0)
              | (~S1 &  S0 & I1)
              | ( S1 & ~S0 & I2)
              | ( S1 &  S0 & I3);*/
endmodule</code></pre>


<hr />
<h3 id="module_lib/gates/generic/NAND2.sv">
Module "NAND2", lib/gates/generic/NAND2.sv
</h3>

<h4>Parameters:</h4>
<ul>
    <li>
    WIDTH
    </li>

</ul>

<h4>Ports:</h4>
<ul>
    <li>
    <pre>in1      input    wire [WIDTH-1:0]</pre>
    </li>

    <li>
    <pre>in2      input    wire [WIDTH-1:0]</pre>
    </li>

    <li>
    <pre>out      output   wire [WIDTH-1:0]</pre>
    </li>

</ul>

<p>2-input NAND.</p>
<script type="WaveDrom">
{ assign:[
  ["out",
    ["~&", "in1", "in2"]
  ]
]}
</script>
<p>Source code:</p>
<pre><code class="lang-verilog">module NAND2 #(
    parameter WIDTH = 1
)(
    input  wire [WIDTH-1:0] in1,
    input  wire [WIDTH-1:0] in2,
    output wire [WIDTH-1:0] out
);

    assign out = ~(in1 & in2);

endmodule</code></pre>


<hr />
<h3 id="module_lib/parts/FullAdderAOI.sv">
Module "FullAdderAOI", lib/parts/FullAdderAOI.sv
</h3>

<h4>Parameters:</h4>
<ul>
</ul>

<h4>Ports:</h4>
<ul>
    <li>
    <pre>in1      input    wire</pre>
    </li>

    <li>
    <pre>in2      input    wire</pre>
    </li>

    <li>
    <pre>ci       input    wire</pre>
     carry in
    </li>

    <li>
    <pre>sum      output   wire</pre>
    </li>

    <li>
    <pre>co       output   wire</pre>
     carry out
    </li>

</ul>

<p>Full Adder using And-Or-Invert (AOI) logic.</p>
<p>Author: Igor Lesik 2020.</p>
<p>AOI logic is a technique of using equivalent Boolean logic expressions
to reduce the number of gates required for a particular expression.
This, in turn, reduces capacitance and consequently propagation times.</p>
<p>For this design, AOI logic has been applied to the calculation of the <em>Sum</em> bit:</p>
<p>Sum = A  B  C = (A + B + C)~C + ABC</p>
<p>where C = AB + C(A + B)</p>
<p>Instead of using two XOR gates to implement the Sum bit,
the circuit takes advantage of the fact that ~C already computed
and uses fewer gates to calculate the rest of the expression.</p>
<script type="WaveDrom">
{ assign:[
  ["co_n",
    ["~|", ["&",["|","in1","in2"],"ci"], ["&","in1","in2"]]
  ],
  ["co",
    ["~", "co_n"]
  ],
  ["sum_n",
    ["~|", ["&",["|","in1","in2","ci"],"co_n"], ["&","in1","in2","ci"]]
  ],
  ["sum",
    ["~", "sum_n"]
  ]
]}
</script>
<p>Source code:</p>
<pre><code class="lang-verilog">module FullAdderAOI (
    input  wire in1,
    input  wire in2,
    input  wire ci,  // carry in
    output wire sum,
    output wire co   // carry out
);

     wire co_n, sum_n;

     assign co = ~co_n;
     assign sum = ~sum_n;

     AOI22 aoi_co_(.out(co_n), .in1(in1|in2), .in2(ci), .in3(in1), .in4(in2));

     AOI22 aoi_sum_(.out(sum_n), .in1(co_n), .in2(in1|in2|ci), .in3(in1), .in4(in2 & ci));

endmodule</code></pre>


<hr />
<h3 id="module_lib/parts/RippleCarryAdder.sv">
Module "RippleCarryAdder", lib/parts/RippleCarryAdder.sv
</h3>

<h4>Parameters:</h4>
<ul>
    <li>
    WIDTH
    </li>

</ul>

<h4>Ports:</h4>
<ul>
    <li>
    <pre>in1      input    wire [WIDTH-1:0]</pre>
    </li>

    <li>
    <pre>in2      input    wire [WIDTH-1:0]</pre>
    </li>

    <li>
    <pre>ci       input    wire</pre>
    </li>

    <li>
    <pre>co       output   wire</pre>
    </li>

    <li>
    <pre>sum      output   wire [WIDTH-1:0]</pre>
    </li>

</ul>

<ul>
<li><a href="https://www.computer.org/csdl/pds/api/csdl/proceedings/download-article/12OmNyfvpTj/pdf">Fast Ripple-Carry Adders in Standard-Cell CMOS VLSI</a>
 -<a href="http://web.engr.uky.edu/~elias/projects/10.pdf">CMOS Binary Full Adder, A Survey of Possible Implementations</a></li>
</ul>
<p>Source code:</p>
<pre><code class="lang-verilog">module RippleCarryAdder #(
    parameter WIDTH = 64
)(
    input  wire [WIDTH-1:0] in1,
    input  wire [WIDTH-1:0] in2,
    input  wire             ci,
    output wire             co,
    output wire [WIDTH-1:0] sum
);

    /* verilator lint_off UNOPTFLAT */
    wire [WIDTH:0] carry;
    /* verilator lint_on UNOPTFLAT */
    assign carry[0] = ci;
    assign co = carry[WIDTH];

    genvar i;
    generate
        for (i = 0; i < WIDTH; i++) begin : fa_gen
            FullAdderAOI fa_(
                .in1(in1[i]),
                .in2(in2[i]),
                .ci (carry[i]),
                .sum(sum[i]),
                .co (carry[i+1])
            );
        end
    endgenerate

endmodule</code></pre>


<hr /></div>
</body></html>
